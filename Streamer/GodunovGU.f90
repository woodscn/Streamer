! This file is automatically generated from
! Godunov.f90.f90 and from GeneralUtilities.f90
module GeneralUtilities
  real(8), parameter :: EPS = 5.d-15
  real(8), parameter :: EPSs = 1d-4
  real(8), parameter :: gamma_const = 1.4d0
  real(8), parameter :: gamma1 = 1.d0/(gamma_const-1.d0)
  real(8), parameter :: gamma2 = (gamma_const-1.d0)
  real(8), parameter :: gamma3 = (gamma_const - 1.d0)/(2.d0*gamma_const)
  real(8), parameter :: gamma4 = 1.d0/gamma3
  real(8), parameter :: gamma5 = (gamma_const-1.d0)/(gamma_const+1.d0)
  real(8), parameter :: gamma6 = 1.d0/(gamma_const+1.d0)
  real(8), parameter :: gamma7 = 1.d0/gamma3

contains
  function MetricInverse(Metric)
    implicit none
    ! Given a list of metric variables:
    ! dx/dxi, dy/dxi, dz/dxi, dx/deta, dy/deta, dz/deta, 
    ! dx/dzeta, dy/dzeta, dz/dzeta
    ! ( A, B, C, L, M, N, P, Q, R )
    ! Return the inverse of this list:
    ! dxi/dx, deta/dx, dzeta/dx, dxi/dy, deta/dy, dzeta/dy,
    ! dxi/dz, deta/dz, dzeta/dz.
    real(8), dimension(9), intent(in) :: Metric
    real(8), dimension(9) :: MetricInverse
    real(8) :: J
    
    J = Jacobian(Metric)
    MetricInverse = [&
         Metric(5)*Metric(9) - Metric(6)*Metric(8), &
         Metric(3)*Metric(8) - Metric(2)*Metric(9), &
         Metric(2)*Metric(6) - Metric(3)*Metric(5), &
         Metric(6)*Metric(7) - Metric(4)*Metric(9), &
         Metric(1)*Metric(9) - Metric(3)*Metric(7), &
         Metric(3)*Metric(4) - Metric(1)*Metric(6), &
         Metric(4)*Metric(8) - Metric(5)*Metric(7), &
         Metric(2)*Metric(7) - Metric(1)*Metric(8), &
         Metric(1)*Metric(5) - Metric(2)*Metric(4) ]/J
  end function MetricInverse

  function MetrictoMatrix(Metric)
    implicit none
    ! Given a 9-element, rank-1 array, convert it to a 3x3 matrix,
    ! such that the elements are ordered column-wise:
    ! [ A, B, C, L, M, N, P, Q, R ]
    !               
    !              | |
    !             \   /
    !              \ /
    !               
    !            A, L, P
    !            B, M, Q
    !            C, N, R
    !
    ! This is consistent with the statement:
    ! dx = matmul(MetrictoMatrix(Metric),dxi)
    real(8), dimension(9), intent(in) :: Metric
    real(8), dimension(3,3) :: MetrictoMatrix

    MetrictoMatrix = reshape([Metric(1),Metric(4),Metric(7),&
         Metric(2),Metric(5),Metric(8),Metric(3),Metric(6),&
         Metric(9)],[3,3])
  end function MetrictoMatrix
  
  subroutine ComputationalGrads(metric,jac,grad_xi,grad_eta,grad_zeta)
    implicit none
    ! Metric has the form:
    !   1  2  3  4  5  6  7  8  9  
    ! [ A, B, C, L, M, N, P, Q, R ]
    ! dx/dxi, dy/dxi, dz/dxi, dx/deta, dy/deta, 
    ! dz/deta, dx/dzeta, dy/dzeta, dz/dzeta
    ! 
    ! ComputationalGrads returns:
    ! grad_xi   = [   dxi/dx,   dxi/dy,   dxi/dz ]
    ! grad_eta  = [  deta/dx,  deta/dy,  deta/dz ]
    ! grad_zeta = [ dzeta/dx, dzeta/dy, dzeta/dz ]
    real(8), intent(in), dimension(9) :: metric
    real(8), intent(in) :: jac
    real(8), intent(out), dimension(3) :: grad_xi
    real(8), intent(out), dimension(3) :: grad_eta
    real(8), intent(out), dimension(3) :: grad_zeta
    real(8), dimension(9) :: inv_metric
    
    inv_metric = MetricInverse(metric)
    grad_xi   = inv_metric(1:9:3)
    grad_eta  = inv_metric(2:9:3)
    grad_zeta = inv_metric(3:9:3)
  end subroutine ComputationalGrads

  real(8) function Jacobian(in)
    implicit none
    ! Computes the determinant of a 3 x 3 matrix using a brute-force method:
    !       | A L P |
    !  J =  | B M Q |
    !       | C N R |
    ! Assumes the structure of in(:) is :
    !   1  2  3  4  5  6  7  8  9 
    ! [ A, B, C, L, M, N, P, Q, R ]
    real(8), dimension(9), intent(in) :: in
    Jacobian = &
         in(1)*in(5)*in(9) - in(1)*in(6)*in(8) + & ! A*M*R - A*N*Q
         in(2)*in(6)*in(7) - in(2)*in(4)*in(9) + & ! B*N*P - B*L*R
         in(3)*in(4)*in(8) - in(3)*in(5)*in(7)     ! C*L*Q - C*M*P
  end function Jacobian

  function GradstoMatrix(Grad1,Grad2,Grad3)
    ! 
    ! matmul(GradstoMatrix,vector) ==
    ! [ sum(GradstoMatrix(1,:)*vector),
    !   sum(GradstoMatrix(2,:)*vector),
    !   sum(GradstoMatrix(3,:)*vector) ]
    implicit none
    real(8), dimension(3), intent(in) :: Grad1, Grad2, Grad3
    real(8), dimension(3,3) :: GradstoMatrix
    GradstoMatrix = transpose(reshape([Grad1,Grad2,Grad3],[3,3]))
  end function GradstoMatrix
  
  subroutine TwoDGradient(in,dx,dy,nx,ny,gradx,grady)
    implicit none
    ! Compute the 2-dimensional gradient of a matrix using central 
    ! differencing wherever possible. Returns gradient matrices 
    ! the same size and shape as the input matrix. If the input matrix 
    ! has length 1 in either dimension, then it is assumed that the
    ! gradient in that dimension is 0.
    real(8), intent(in), dimension(nx,ny) :: in
    real(8), intent(in) :: dx, dy
    integer, intent(in) :: nx, ny
    real(8), intent(out), dimension(nx,ny) :: gradx, grady
    integer :: i, j

    if(nx>1)then
       ! Central differencing where possible
       gradx(2:nx-1,:) = .5d0*(in(3:nx,:)-in(1:nx-2,:))/dx
       ! Forward & backward differencing elsewhere
       gradx(1,:)  = (in( 2,:)-in(   1,:))/dx
       gradx(nx,:) = (in(nx,:)-in(nx-1,:))/dx
    else
       gradx(:,:) = 0.d0
    end if
    if(ny>1)then
       ! Central differencing where possible
       grady(:,2:ny-1) = .5d0*(in(:,3:ny)-in(:,1:ny-2))/dy
       ! Forward & backward differencing elsewhere
       grady(:,1)  = (in(:, 2)-in(:,   1))/dy
       grady(:,ny) = (in(:,ny)-in(:,ny-1))/dy
    else
       grady(:,:) = 0.d0
    end if
  end subroutine TwoDGradient

  function MatrixInverse(in)
    ! Compute the inverse of a 3x3 matrix
    implicit none
    real(8), dimension(3,3), intent(in) :: in
    real(8), dimension(3,3) :: MatrixInverse
    real(8) :: J
    
    J = ( &
         in(1,1)*in(2,2)*in(3,3) + &
         in(1,2)*in(2,3)*in(3,1) + &
         in(1,3)*in(2,1)*in(3,2) - &
         in(1,1)*in(2,3)*in(3,2) - &
         in(1,2)*in(2,1)*in(3,3) - &
         in(1,3)*in(2,2)*in(3,1) )

    MatrixInverse = transpose(reshape( [ & 
         in(3,3)*in(2,2)-in(3,2)*in(2,3) , &
         in(3,2)*in(1,3)-in(3,3)*in(1,2) , &
         in(2,3)*in(1,2)-in(2,2)*in(1,3) , &
         in(3,1)*in(2,3)-in(3,3)*in(2,1) , &
         in(3,3)*in(1,1)-in(3,1)*in(1,3) , &
         in(2,1)*in(1,3)-in(2,3)*in(1,1) , &
         in(3,2)*in(2,1)-in(3,1)*in(2,2) , &
         in(3,1)*in(1,2)-in(3,2)*in(1,1) , &
         in(2,2)*in(1,1)-in(2,1)*in(1,2) ] &
         ,[3,3])/J)
    if(.true. .and. maxval(matmul(in,MatrixInverse)&
            -reshape([1,0,0,0,1,0,0,0,1],[3,3]))**2>1.d-15)then
          write(*,*) "MatrixInverse failed!!"
          write(*,*) matmul(in,MatrixInverse)
          stop
    end if
  end function MatrixInverse

  function vectorProjection(in,normal)
    implicit none
    real(8), intent(in), dimension(3) :: in
    real(8), intent(in), dimension(3) :: normal
    real(8), dimension(3) :: vectorProjection
    vectorProjection = normal*&
         (dot_product(in,normal)/dot_product(normal,normal))
  end function vectorProjection

  real(8) function SoundSpeed(point)
    implicit none
    real(8), intent(in), dimension(21) :: point
    SoundSpeed = sqrt(1.4d0*point(1)/point(2))
  end function SoundSpeed

!!$  logical function pnpoly(npol,xp,yp,x,y)
!!$    ! Check to see if a point lies on the interior of a polygon.
!!$    ! The polygon is given by  x,y points in xp & yp. The point
!!$    ! to test is given by x, y.
!!$    ! Returns true if within the polygon, false otherwise.
!!$
!!$    ! Uses the method of counting the number of times a ray from 
!!$    ! the point crosses the polygon. Original C code given on
!!$    ! http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/
!!$    ! and written by Randolph Franklin.
!!$
!!$    ! int pnpoly(int npol, float *xp, float *yp, float x, float y)
!!$    !     {
!!$    !       int i, j, c = 0;
!!$    !       for (i = 0, j = npol-1; i < npol; j = i++) {
!!$    !         if ((((yp[i] <= y) && (y < yp[j])) ||
!!$    !              ((yp[j] <= y) && (y < yp[i]))) &&
!!$    !             (x < (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i]))
!!$    !           c = !c;
!!$    !       }
!!$    !       return c;
!!$    !     }
!!$    implicit none
!!$    integer :: npol
!!$    real(8) :: x, y
!!$    real(8), dimension(npol) :: xp, yp
!!$    integer :: i, j, n
!!$
!!$    pnpoly = .false.
!!$    n = size(xp)
!!$    do i = 1, size(xp)
!!$       if(i==1)then
!!$          j = n
!!$       else
!!$          j = i-1
!!$       end if
!!$       if((((yp(i)<=y).and.(y<yp(j))).or.&
!!$            ((yp(j)<=y).and.(y<yp(i)))).and.&
!!$            (x<(xp(j)-xp(i))*(y-yp(i))/(yp(j)-yp(i))+xp(i)))&
!!$            pnpoly = .not. pnpoly
!!$       write(*,*) "i = ",i,"j = ",j       
!!$    end do
!!$
!!$  end function pnpoly 

end module GeneralUtilities

module GeneralUtilitiesTest
  use GeneralUtilities
contains
  integer function GUErrorReader(in)
    implicit none
    integer, intent(in) :: in
    write(*,*) " GeneralUtilities.f90 diagnostic:"
    select case(in)
    case(0)
       write(*,*) "   All tests passed"
    case(1) 
       write(*,*) "   Combined test of metrictomatrix and metricinverse failed"
    case(2)
       write(*,*) "   TwoDGradient does not converge at the expected rate"
    case default
       write(*,*) "   Unexpected error code"
    end select
    GUErrorReader = 0
  end function GUErrorReader

  integer function GUTest()
    ! Test the following routines:
    !   function MetricInverse(Metric)
    !   function MetrictoMatrix(Metric)
    !   subroutine ComputationalGrads(metric,jac,grad_xi,grad_eta,grad_zeta)
    !   function Jacobian(in)
    !   function GradstoMatrix(Grad1,Grad2,Grad3)
    !   subroutine TwoDGradient(in,dx,dy,nx,ny,gradx,grady)

    ! Returns an integer error code.
    ! 0: All tests passed
    ! 1: Combined test of metrictomatrix and metricinverse failed
    ! 2: TwoDGradient does not converge at the expected rate
    implicit none
    real(8), dimension(9) :: metric
    real(8), dimension(3,3) :: matrix
    real(8), dimension(0:3) :: p1, p2, p3
    integer :: out, i, j, k, n, nx, ny
    real(8), dimension(400,400) :: test, grad_test_x, grad_test_y
    real(8), dimension( 50, 50) :: num_test_1x, num_test_1y
    real(8), dimension(100,100) :: num_test_2x, num_test_2y
    real(8), dimension(200,200) :: num_test_3x, num_test_3y
    real(8), dimension(400,400) :: num_test_4x, num_test_4y
    real(8), dimension(4) :: dxes, rmserrors
    real(8), dimension(2) :: fitted_poly
    real(8) :: dx, dy
    real(8) :: x, y
    
    out = 0
    ! Try variable ranges on these random numbers to check to handle 
    ! ill-conditioned matrices
    call random_number(metric)
    call random_number(p1)
    call random_number(p2)
    call random_number(p3)
    matrix=matmul(metrictomatrix(metric),metrictomatrix(metricinverse(metric)))
    if(maxval((matrix-reshape([1.,0.,0.,0.,1.,0.,0.,0.,1.],[3,3]))**2)>1.d-14) out = 1
    nx = size(test,1)
    ny = size(test,2)
    dx = 12./nx
    dy = 13./ny
    do j = 1, ny
       do i = 1, nx
          x = i*dx
          y = j*dy
          test(i,j) = 0.d0
          grad_test_x(i,j) = 0.d0
          grad_test_y(i,j) = 0.d0
          do n = 0, size(p1) - 1
             test(i,j) = test(i,j) + p1(n)*x**n + p2(n)*y**n
             grad_test_x(i,j) = grad_test_x(i,j) + n*p1(n)*x**(n-1)
             grad_test_y(i,j) = grad_test_y(i,j) + n*p2(n)*y**(n-1)
          end do
       end do
    end do
    call TwoDGradient(test(1:nx:8,1:ny:8),dx*8,dy*8,nx/8,ny/8,&
         num_test_1x,num_test_1y)
    call TwoDGradient(test(1:nx:4,1:ny:4),dx*4,dy*4,nx/4,ny/4,&
         num_test_2x,num_test_2y)
    call TwoDGradient(test(1:nx:2,1:ny:2),dx*2,dy*2,nx/2,ny/2,&
         num_test_3x,num_test_3y)
    call TwoDGradient(test,dx,dy,nx,ny,num_test_4x,num_test_4y)

    dxes = [dx*8,dx*4,dx*2,dx]
    rmserrors = [sqrt(sum((num_test_1x-grad_test_x(1:nx:8,1:ny:8))**2)&
         /size(num_test_1x)),&
         sqrt(sum((num_test_2x-grad_test_x(1:nx:4,1:ny:4))**2)&
         /size(num_test_2x)),&
         sqrt(sum((num_test_3x-grad_test_x(1:nx:2,1:ny:2))**2)&
         /size(num_test_3x)),&
         sqrt(sum((num_test_4x-grad_test_x)**2)/size(num_test_4x))]

    fitted_poly = polyfit(log(dxes),log(rmserrors),1)
    if(fitted_poly(2) < 1.) out = 2
    GUTest = out
    
  end function GUTest


  ! From Rosetta Code: rosettacode.org/wiki/PolynomialRegression#Fortran
  ! Requires LAPACK library
  ! Verified for single-case linear fit against Mathematica, 27 Aug 2012.
  function polyfit(vx, vy, d)
    implicit none
    integer, intent(in)                   :: d
    integer, parameter                    :: dp = selected_real_kind(15, 307)
    real(dp), dimension(d+1)              :: polyfit
    real(dp), dimension(:), intent(in)    :: vx, vy
 
    real(dp), dimension(:,:), allocatable :: X
    real(dp), dimension(:,:), allocatable :: XT
    real(dp), dimension(:,:), allocatable :: XTX
 
    integer :: i, j
 
    integer     :: n, lda, lwork
    integer :: info
    integer, dimension(:), allocatable :: ipiv
    real(dp), dimension(:), allocatable :: work
 
    n = d+1
    lda = n
    lwork = n
 
    allocate(ipiv(n))
    allocate(work(lwork))
    allocate(XT(n, size(vx)))
    allocate(X(size(vx), n))
    allocate(XTX(n, n))
 
    ! prepare the matrix
    do i = 0, d
       do j = 1, size(vx)
          X(j, i+1) = vx(j)**i
       end do
    end do
 
    XT  = transpose(X)
    XTX = matmul(XT, X)
 
    ! calls to LAPACK subs DGETRF and DGETRI
    call DGETRF(n, n, XTX, lda, ipiv, info)
    if ( info /= 0 ) then
       print *, "problem"
       return
    end if
    call DGETRI(n, XTX, lda, ipiv, work, lwork, info)
    if ( info /= 0 ) then
       print *, "problem"
       return
    end if
 
    polyfit = matmul( matmul(XTX, XT), vy)
 
    deallocate(ipiv)
    deallocate(work)
    deallocate(X)
    deallocate(XT)
    deallocate(XTX)
 
  end function
 
end module GeneralUtilitiesTest

!!$program test_regime
!!$  use generalutilitiestest
!!$  implicit none
!!$  integer :: result, junk
!!$  result = GUTest()
!!$  junk = GUErrorReader(result)
!!$!  write(*,*) GUErrorReader(result)
!!$end program test_regime
module Riemann
  use GeneralUtilities
  logical :: verbose = .false.
  logical :: riemann_test_flag 
  logical :: test_flag = .false.
  real(8), dimension(4) :: test_sol
contains

  function riemann_solve( left, right, geom_avg, max_wave_speed, t_out )
    ! Riemann_solve accepts two physical flow states of the form:
    !     [ pressure, mass density, velocity_normal, velocity_tangential_1,
    !       velocity_tangential_2 ]
    !   as well as an average geometric state of the form:
    !     [ pressure, density, v_norm, v_tan1, v_tan2, A, B, C, L, M, N, 
    !       P, Q, R, U, V, W, x, y, z, J ]
    ! Riemann_solve solves the 1-dimensional riemann problem given by 
    !   the left and right states, as well as the grid motion U, V, W.
    !   It returns the state value [ p, rho, v_norm, v_tan1, v_tan2 ] 
    !   at x/t = 0. It also updates the maximum wavespeed encountered,
    !   for use in computing an optimal time step. 
    ! With some small updates, it is possible to have riemann_solve return
    !   the flow state as an array for various values of x/t. This is more
    !   useful for debugging, and is the purpose of the optional argument
    !   t_out.
    implicit none
    real(8), dimension(5), intent(in) :: left, right
    real(8), dimension(21), intent(in) :: geom_avg
    real(8), dimension(5) :: riemann_solve
    real(8), intent(out) :: max_wave_speed
    real(8), intent(in), optional :: t_out
    real(8) :: tout = 1.d0
    integer :: n
    integer, parameter :: nx = 1000

    real(8) :: DL, PL, UL, VL, WL, AL
    real(8) :: DR, PR, UR, VR, WR, AR
    real(8) :: Pstar, Ustar, DstarL, DstarR
    real(8) :: tol = 1.d-10, x
    real(8) :: PsiL, PsiR, temp=1.d0, fL, fR, dfL, dfR
    real(8), dimension(nx,5) :: data

    if(present(t_out)) tout = t_out
    DL =  left(2) ; PL =  left(1) ; UL =  left(3) ; VL =  left(4) ; WL =  left(5)
    DR = right(2) ; PR = right(1) ; UR = right(3) ; VR = right(4) ; WR = right(5)
    AL = sqrt(gamma_const*PL/DL) ; AR = sqrt(gamma_const*PR/DR)

    Pstar = guessp(left,right)
    if(verbose)write(*,*) "Initial guess P = " , Pstar
    temp = 1.d0 ; n = 0
    do while(abs(temp) .gt. tol)
       if(verbose)write(*,*) "Step ",n , "Pstar = " , Pstar; 
       n = n + 1
       if(n .gt. 10)then 
          write(*,*) "Failed Convergence" 
          stop 
       end if
       PsiL = Pstar/PL
       call u_fun( left,Pstar,fL,dfL)
       PsiR = Pstar/PR
       call u_fun(right,Pstar,fR,dfR)
       temp = ( UR - UL + fR + fL )/( dfL + dfR )
       Pstar = max( Pstar - temp , tol )
       if(verbose)write(*,*) "fL , fR , Pstar = " , fL , fR , Pstar
    end do
    Ustar = .5*(UR+fR+UL-fL)
    DstarL = beta(Pstar/PL)*DL
    DstarR = beta(Pstar/PR)*DR
    if(test_flag)then
       riemann_test_flag = sqrt(sum(([Pstar,Ustar,DstarL,DstarR]-test_sol)**2&
            /test_sol)/4d0)>1d-4 ! Toro only give the results in significant figures
!!$       if(riemann_test_flag)then
!!$          write(*,*) [Pstar,Ustar,DstarL,DstarR]
!!$          write(*,*) test_sol
!!$          read(*,*)
!!$       end if
    end if
    if(PsiL<1.d0)then
       max_wave_speed = abs(left(3) - .5d0*(UL+UR) - aL)
    else
       max_wave_speed = abs(left(3)-.5d0*(UL+UR)-aL*sqrt((gamma_const+1.d0)/&
            (2.d0*gamma_const)*(PsiL-1.d0)+1.d0))
    end if
    if(PsiR<1.d0)then
       max_wave_speed = max(abs(right(3) - .5d0*(UL+UR) + aR),max_wave_speed)
    else
       max_wave_speed = max(abs(right(3)-.5*(UL+UR)+aR*sqrt((gamma_const+1.d0)/&
            (2.d0*gamma_const)*(PsiR-1.d0)+1.d0)),max_wave_speed)
    end if
    if(verbose)write(*,*) Ustar , DstarL , DstarR
    call sample(0D0,left,right,geom_avg,Pstar,Ustar,DstarL,DstarR,riemann_solve)
    if(verbose)write(*,*)"RiemannSolve = ", riemann_solve
  end function riemann_solve

  real(8) pure function guessp(left,right)
    implicit none
    real(8), dimension(:), intent(in) :: left, right
    real(8) :: aL, aR, gL, gR, tol
    aL = sqrt(gamma_const* left(1)/ left(2))
    aR = sqrt(gamma_const*right(1)/right(2))
    tol = 1d-8
    ! Linearised guess
    guessp = .5*(left(1)+right(1))&
         -.125*(right(3)-left(3))*(left(2)+right(2))*(aL+aR)
    if(.not.( guessp .gt. min(left(1),right(1)) .and. guessp .lt. max(left(1),right(1)) &
         .and. max(left(1),right(1))/min(left(1),right(1)) .le. 2.0))then
       if(guessp .lt. min(left(1),right(1)))then
          ! Two-rarefaction solution
          guessp = (&
               (aL+aR-.5*(gamma_const-1.)*(right(3)-left(3)))&
               /(aL/left(1)**((gamma_const-1.)/(2.*gamma_const))&
               +aR/right(1)**((gamma_const-1.)/(2.*gamma_const)))&
               )**(2.*gamma_const/(gamma_const-1.))
       else
          ! Two-shock solution
          gL=sqrt( 2./((gamma_const+1.)* left(2))/(guessp+ left(1)*(gamma_const-1.)/(gamma_const+1.)))
          gR=sqrt( 2./((gamma_const+1.)*right(2))/(guessp+right(1)*(gamma_const-1.)/(gamma_const+1.)))
          guessp = max(tol,(gL*left(1)+gR*right(1)-(right(3)-left(3)))/(gL+gR))
       end if
    end if
    !          guessp = .5*( PL + PR )
  end function guessp

  pure subroutine u_fun(in,pstar,f,df)
    real(8), dimension(:), intent(in) :: in
    real(8), intent(in) :: pstar
    real(8) , intent(out) :: f , df
    real(8) :: A, B, psi, a0
    psi = pstar/in(1)
    a0  = sqrt(gamma_const*in(1)/in(2))
    if( psi .gt. 1. )then
       A = 2.d0/((gamma_const+1.d0)*in(2))
       B = (gamma_const-1.d0)/(gamma_const+1.d0)*in(1)
       f = in(1)*(psi-1.d0)*sqrt(A/(in(1)*psi+B))
       df= sqrt(A/(B+in(1)*psi))*(1.d0-in(1)*(psi-1.d0)/(2.*(B+psi*in(1))))
    else
       f = 2.d0*a0/(gamma_const-1.d0)*(psi**((gamma_const-1.d0)/(2.d0*gamma_const))-1.d0)
       df= 1.d0/(in(2)*a0)*psi**((gamma_const+1.d0)/(-2.d0*gamma_const))
    end if
  end subroutine u_fun

  pure function beta(psi)
    implicit none
    real(8), intent(in) :: psi
    real(8) :: beta
    if( psi .gt. 1 )then
       beta = ((gamma_const+1.)*psi+gamma_const-1.)/(gamma_const+1.+(gamma_const-1.)*psi)
    else
       beta = psi**(1.d0/gamma_const)
    end if
  end function beta

  subroutine sample(x,left,right,geom_avg,Pstar,Ustar,DstarL,DstarR,out)    
    implicit none
    real(8), dimension(:), intent(in) :: left, right, geom_avg
    real(8), intent(in) :: Pstar, Ustar, DstarL, DstarR, x
    real(8), dimension(:) , intent(out) :: out
    real(8) :: PsiL , SL , SR , DeltaL, DeltaR
    real(8) :: PsiR , aL , aR , betaL , betaR
    real(8) :: cL , cR , cLT , cLH , cRT , cRH , h
    logical :: test_flag = .false.
    real(8) :: Uavg
    if(verbose) test_flag = .true.
    Uavg = geom_avg(15) ! The average of the normal grid velocity
    PsiL = Pstar/left(1)
    PsiR = Pstar/right(1)
    aL   = sqrt(gamma_const* left(1)/ left(2))
    aR   = sqrt(gamma_const*right(1)/right(2))
    betaL= DstarL/ left(2)
    betaR= DstarR/right(2)
    if( Ustar .gt. x )then
       if(test_flag) write(*,*) "The boundary lies to the left of the contact wave"
       out(4) = left(4) ; out(5) = left(5)
       if( PsiL .gt. 1.d0 )then
          if(test_flag) write(*,*) " Left shock"
          cL = left(3)-Uavg-aL*sqrt((gamma_const+1.d0)/(2.d0*gamma_const)*(PsiL-1.d0)+1.d0)
          if(test_flag)cL = cL*SL/DeltaL
          if(test_flag) write(*,*) "Left shock speed = " , cL
          if( cL .gt. x )then
             if(test_flag) write(*,*) " The boundary lies to the left of the shock"
             out(1) = left(1)
             out(3) = left(3)
             out(2) = left(2)
          else
             if(test_flag) write(*,*) " The boundary lies in the left central region"
             out(1) = Pstar
             out(3) = Ustar
             out(2) = DstarL
          end if
       else
          if(test_flag) write(*,*) "Left rarefaction wave"
          cLT = left(3) - Uavg - aL
          if(test_flag) cLT = cLT*SL/DeltaL
          if(test_flag) write(*,*) "Left rarefaction tail speed = " , cLT
          cLH = Ustar-Uavg - sqrt(gamma_const*Pstar/DstarL)
          if(test_flag) write(*,*) "Left rarefaction head speed = " , cLH
          if( cLT .gt. x )then
             if(test_flag) write(*,*) " The boundary lies to the left of the wave"
             out(1) = left(1)
             out(3) = left(3)
             out(2) = left(2)
          elseif( cLH .lt. x )then
             if(test_flag) write(*,*) "The boundary lies in the left central region"
             out(1) = Pstar
             out(3) = Ustar
             out(2) = DstarL
          else
             if(test_flag) write(*,*) "The boundary lies within the left expansion wave"
             out(1) = left(1)*( 2.d0*gamma6 + gamma5/aL*(left(3)-Uavg) )**gamma7
             out(3) = left(3) - 2.d0*aL/(gamma_const-1.d0)*((out(1)/left(1))&
                  **((gamma_const-1.d0)/(2.d0*gamma_const))-1.d0)
             out(2) = left(2)*(out(1)/left(1))**(1.d0/gamma_const)
          end if
       end if
    else
       if(test_flag) write(*,*) " The boundary lies to the right of the contact wave"
       out(4) = right(4) ; out(5) = right(5)
       if( PsiR .gt. 1. )then
          if(test_flag) write(*,*) " Right shock"
          cR = right(3)-Uavg+aR*sqrt((gamma_const+1.d0)/(2.d0*gamma_const)*(PsiR-1.d0)+1.d0)
          if(test_flag) cR = cR*SR/DeltaR
          if(test_flag) write(*,*) " Right shock speed = " , cR
          if( cR .lt. x )then
             if(test_flag) write(*,*) " The boundary lies to the right of the shock"
             out(1) = right(1)
             out(3) = right(3)
             out(2) = right(2)
          else
             if(test_flag) write(*,*) " The boundary lies in the right central region"
             out(1) = Pstar
             out(3) = Ustar
             out(2) = DstarR
          end if
       else
          if(test_flag) write(*,*) " Right rarefaction wave"
          cRT = right(3) - Uavg + aR
          if(test_flag) cRT = cRT*SR/DeltaR
          if(test_flag) write(*,*) "Right rarefaction tail speed = " , cRT
          cRH = Ustar - Uavg + sqrt(gamma_const*Pstar/DstarR)
          if(test_flag) write(*,*) "Right rarefaction head speed = " , cRH
          if( cRT .lt. x )then
             if(test_flag) write(*,*) " The boundary lies to the right of the wave"
             out(1) = right(1)
             out(3) = right(3)
             out(2) = right(2)
          elseif( cRH .gt. x )then
             if(test_flag) write(*,*) "The boundary lies in the right central region"
             out(1) = Pstar
             out(3) = Ustar
             out(2) = DstarR
          else
             if(test_flag) write(*,*) " The boundary lies within the right expansion wave"
             out(1) = right(1)*( 2.d0*gamma6 - gamma5/aR*(right(3)-Uavg) )**gamma7
             out(3) = right(3) + 2.d0*aR/(gamma_const-1.d0)*((out(1)/right(1))**&
                  ((gamma_const-1.d0)/(2.d0*gamma_const))-1.d0)
             out(2) = right(2)*(out(1)/right(1))**(1.d0/gamma_const)
          end if
       end if
    end if
  end subroutine sample
end module Riemann

module Riemann_tester
  use Riemann
  real(8), dimension(5) :: riemann_sol
  real(8), dimension(21):: test_geom
  real(8) :: mws_test
  ! Though it's possible to do specific tests of the guessp algorithm,
  ! it seems less-effective to do so, since a bad guess will still converge.
!!!$  real(8), parameter :: guess_p_1 = 
!!!$  real(8), parameter :: guess_p_2 = 
!!!$  real(8), parameter :: guess_p_3 = 
!!!$  real(8), parameter :: guess_p_4 = 
!!!$  real(8), parameter :: guess_p_5 = 
contains
  integer function RieErrorReader(in)
    implicit none
    integer, intent(in) :: in
    select case(in)
    case(0)
       write(*,*) "   All tests passed"
    case(1)
       write(*,*) "   Failure in one of the Riemann Star state checks"
    case default
       write(*,*) "   Unexpected error code"
    end select
  end function RieErrorReader

  integer function RieTester()
    implicit none
    real(8), dimension(5) :: test_1_left
    real(8), dimension(5) :: test_1_right
    real(8), dimension(5) :: test_2_left
    real(8), dimension(5) :: test_2_right
    real(8), dimension(5) :: test_3_left
    real(8), dimension(5) :: test_3_right
    real(8), dimension(5) :: test_4_left
    real(8), dimension(5) :: test_4_right
    real(8), dimension(5) :: test_5_left
    real(8), dimension(5) :: test_5_right
    real(8), dimension(4) :: test_1_sol
    real(8), dimension(4) :: test_2_sol
    real(8), dimension(4) :: test_3_sol
    real(8), dimension(4) :: test_4_sol
    real(8), dimension(4) :: test_5_sol
    RieTester = 0
    test_1_left  = [1.d0, 1.d0, 0.d0, 0.d0, 0.d0]
    test_1_right = [.1d0, .125d0, 0.d0, 0.d0, 0.d0]
    test_2_left  = [.4d0, 1.d0, -2.d0, 0.d0, 0.d0]
    test_2_right = [.4d0, 1.d0, 2.d0, 0.d0, 0.d0]
    test_3_left  = [1.d3, 1.d0, 0.d0, 0.d0, 0.d0]
    test_3_right = [.01d0, 1.d0, 0.d0, 0.d0, 0.d0]
    test_4_left  = [.01d0, 1.d0, 0.d0, 0.d0, 0.d0]
    test_4_right = [1.d2, 1.d0, 0.d0, 0.d0, 0.d0]
    test_5_left  = [460.894d0, 5.99924d0, 19.5975d0, 0d0, 0d0]
    test_5_right = [46.095d0, 5.99242d0, -6.19633d0, 0d0, 0d0]
    test_1_sol = [.30313d0, .92745d0, .42632d0, .26557d0]
    test_2_sol = [.00189d0, .00000d0, .02185d0, .02185d0]
    test_3_sol = [460.894d0, 19.5975d0, .57506d0, 5.99924d0]
    test_4_sol = [46.095d0, -6.19633d0, 5.99242d0, .57511d0]
    test_5_sol = [1691.64d0, 8.68975d0, 14.2823d0, 31.0426d0]
    ! Test riemann_solve against the test problems from Toro. This only tests
    ! whether Pstar, Ustar, DstarL and DstarR are correct.
    test_flag = .true.
    test_geom = [0d0,0d0,0d0,0d0,0d0,&
         1d0,0d0,0d0,0d0,1d0,0d0,0d0,0d0,1d0,&
         0d0,0d0,0d0,0d0,0d0,0d0,1d0]
    test_sol = test_1_sol
    riemann_sol = riemann_solve(test_1_left,test_1_right,test_geom,mws_test,1.d0)
    if(riemann_test_flag) RieTester = 1
    test_sol = test_2_sol
    riemann_sol = riemann_solve(test_2_left,test_2_right,test_geom,mws_test,1.d0)
    if(riemann_test_flag) RieTester = 1
    test_sol = test_3_sol
    riemann_sol = riemann_solve(test_3_left,test_3_right,test_geom,mws_test,1.d0)
    if(riemann_test_flag) RieTester = 1
    test_sol = test_4_sol
    riemann_sol = riemann_solve(test_4_left,test_4_right,test_geom,mws_test,1.d0)
    if(riemann_test_flag) RieTester = 1
    test_sol = test_5_sol
    riemann_sol = riemann_solve(test_5_left,test_5_right,test_geom,mws_test,1.d0)
    if(riemann_test_flag) RieTester = 1
    test_flag = .false.
    
    ! Test sample. This is the routine that uses the geometric information, and
    ! is different from a standard Riemann problem.
  end function RieTester
end module Riemann_tester

module Godunov
  use GeneralUtilities
  use Riemann
  implicit none
  real(8), parameter :: max_dt = 1.d0
  real(8), parameter :: dxi   = 1.d0
  real(8), parameter :: deta  = 1.d0
  real(8), parameter :: dzeta = 1.d0
  real(8), parameter :: dxi_inv   = 1.d0/dxi
  real(8), parameter :: deta_inv  = 1.d0/deta
  real(8), parameter :: dzeta_inv = 1.d0/dzeta
  real(8), parameter :: dV_inv = dxi_inv*deta_inv*dzeta_inv
  integer, parameter :: update_type = 2 ! 1 = FV, 2 = HUI3D

  interface primtocons
     module procedure primtoconsarray
     module procedure primtoconspoint
  end interface primtocons

  interface constoprim
     module procedure constoprimarray
     module procedure constoprimpoint
  end interface constoprim

contains
!  integer elemental function gt0(x)
!    implicit none
!    real(8), intent(in) :: x
!    gt0 = ishft( int(sign(1.d0,x) + 1) , -1 )
!  end function gt0

  ! Computes specific energy, given the array [ p, rho, u, v, w ]
  real(8) function energy_func(in)
    implicit none
    real(8), dimension(:), intent(in) :: in
    energy_func = 0.5d0*(in(3)**2+in(4)**2+in(5)**2) + in(1)/(in(2)*gamma2)
  end function energy_func

  subroutine primtoconsarray(main)
    ! Assumes the structure of prim(:) is :
    !   1   2   3  4  5  
    ! [ p, rho, u, v, w ] - pressure, mass density, cartesian velocity components
    ! J is the Jacobian
    ! Returns the structure of cons(:) :
    !     1       2         3         4       5 
    ! [ rho J, rho J u , rho J v , rho J w , J e ]
    !      e is energy, defined for the ideal gas law by :
    !      .5*rho*(u^2+v^2+w^2) + p/(gamma-1)
    real(8), dimension(:,:,:,:), intent(inout) :: main
    integer, dimension(4) :: en_shape
    real(8), allocatable, dimension(:,:,:) :: energy
    en_shape = shape(main)
    allocate(energy(en_shape(2), en_shape(3), en_shape(4)))
    energy = main(21,:,:,:)*( main(1,:,:,:)*gamma1 + 0.5d0*main(2,:,:,:)&
         *( main(3,:,:,:)**2 + main(4,:,:,:)**2 + main(5,:,:,:)**2 ) )
    main(1,:,:,:) = main(2,:,:,:)*main(21,:,:,:)
    main(2,:,:,:) = main(1,:,:,:)*main(3,:,:,:)
    main(3,:,:,:) = main(1,:,:,:)*main(4,:,:,:)
    main(4,:,:,:) = main(1,:,:,:)*main(5,:,:,:)
    main(5,:,:,:) = energy
    deallocate(energy)
  end subroutine primtoconsarray

  subroutine primtoconspoint(main)
    ! Assumes the structure of prim(:) is :
    !   1   2   3  4  5  
    ! [ p, rho, u, v, w ] - pressure, mass density, cartesian velocity components
    ! J is the Jacobian
    ! Returns the structure of cons(:) :
    !     1       2         3         4       5 
    ! [ rho J, rho J u , rho J v , rho J w , J e ]
    !      e is energy, defined for the ideal gas law by :
    !      .5*rho*(u^2+v^2+w^2) + p/(gamma-1)
    real(8), dimension(:), intent(inout) :: main
    real(8) :: energy
    energy = main(21)*( main(1)*gamma1 + 0.5d0*main(2)&
         *( main(3)**2 + main(4)**2 + main(5)**2 ) )
    main(1) = main(2)*main(21)
    main(2) = main(1)*main(3)
    main(3) = main(1)*main(4)
    main(4) = main(1)*main(5)
    main(5) = energy
  end subroutine primtoconspoint
  
  subroutine constoprimarray(main)
    ! Returns the structure of prim(:) :
    !   1   2   3  4  5  
    ! [ p, rho, u, v, w ] - pressure, mass density, cartesian velocity components
    ! J is the Jacobian
    ! Assume the structure of cons(:) is :
    !     1       2         3         4       5 
    ! [ rho J, rho J u , rho J v , rho J w , J e ]
    !      e is energy, defined for the ideal gas law by :
    !      .5*rho*(u^2+v^2+w^2) + p/(gamma-1)
    real(8), dimension(:,:,:,:), intent(inout) :: main
    integer, dimension(4) :: p_shape
    real(8), allocatable, dimension(:,:,:) :: temp1, temp2, p
    allocate( temp1(p_shape(2), p_shape(3), p_shape(4)) )
    allocate( temp2(p_shape(2), p_shape(3), p_shape(4)) )
    allocate(     p(p_shape(2), p_shape(3), p_shape(4)) )
    temp1 = 1.d0/main(21,:,:,:)
    temp2 = 1.d0/main(1,:,:,:)
    p = gamma2*temp1*( main(5,:,:,:) - .5d0*temp2&
         *( main(2,:,:,:)**2 + main(3,:,:,:)**2 + main(4,:,:,:)**2 )&
         )
    main(5,:,:,:) = main(4,:,:,:)*temp2
    main(4,:,:,:) = main(3,:,:,:)*temp2
    main(3,:,:,:) = main(2,:,:,:)*temp2
    main(2,:,:,:) = main(1,:,:,:)*temp1
    main(1,:,:,:) = p
    deallocate( temp1, temp2, p )
  end subroutine constoprimarray

  subroutine constoprimpoint(main)
    ! Returns the structure of prim(:) :
    !   1   2   3  4  5  
    ! [ p, rho, u, v, w ] - pressure, mass density, cartesian velocity components
    ! J is the Jacobian
    ! Assume the structure of cons(:) is :
    !     1       2         3         4       5 
    ! [ rho J, rho J u , rho J v , rho J w , J e ]
    !      e is energy, defined for the ideal gas law by :
    !      .5*rho*(u^2+v^2+w^2) + p/(gamma-1)
    real(8), dimension(:), intent(inout) :: main
    real(8) :: temp1, temp2, p
    temp1 = 1.d0/main(21)
    temp2 = 1.d0/main(1)
    p = gamma2*temp1*( main(5) - .5d0*temp2&
         *( main(2)**2 + main(3)**2 + main(4)**2 )&
         )
    main(5) = main(4)*temp2
    main(4) = main(3)*temp2
    main(3) = main(2)*temp2
    main(2) = main(1)*temp1
    main(1) = p
  end subroutine constoprimpoint

  function invnorm3(in)
    real(8), dimension(3), intent(in) :: in
    real(8) :: invnorm3
    invnorm3 = 1.d0/sqrt( in(1)**2 + in(2)**2 + in(3)**2 )
  end function invnorm3

  subroutine grid_coords(grad, normal, tangential1, tangential2)
! Compute an orthonormal coordinate system given an initial, unnormalized vector.
    real(8), dimension(:), intent(in) :: grad
    real(8), dimension(3), intent(out) :: normal, tangential1, tangential2
    real(8) :: temp1, temp3
    real(8), dimension(3) :: temp2, temp4
    temp1 = invnorm3(grad)
    normal = grad*temp1
    if( grad(2)**2 + grad(3)**2 < EPS )then
       tangential1 = (/ 0.d0, 1.d0, 0.d0 /)
       tangential2 = (/ 0.d0, 0.d0, 1.d0 /)
    else
       temp2 = (/ 0.d0, -grad(3), grad(2) /)
       temp3 = invnorm3(temp2)
       temp4 = (/ grad(2)**2 + grad(3)**2, -grad(1)*grad(2), -grad(1)*grad(3) /)
       tangential1 = temp2*temp3
       tangential2 = temp1*temp3*temp4
    end if
  end subroutine grid_coords

  subroutine prim_update(main,bcextent,dt_in,CFL,nx,ny,nz)
    implicit none
    real(8), dimension(:,:,:,:) :: main
    !f2py intent(in,out) :: main
    integer :: bcextent, nx, ny, nz
    real(8) :: dt_in, CFL
    select case(update_type)
    case(1)
       call prim_update_FV(main,bcextent,dt_in,CFL,nx,ny,nz)
    case(2)
       call prim_update_HUI3D(main,bcextent,dt_in,CFL,nx,ny,nz)
    case default
       write(*,*) "Bad update_type value!!!"
       stop
    end select
  end subroutine prim_update

!!$  function compute_interfaces_HUI3D(left_in,right_in,row_ops_mat)
!!$    implicit none
!!$    real(8), dimension(21), intent(in) :: left, right
!!$    integer, dimension(3,3), intent(in) :: row_ops_mat
!!$    real(8), dimension(5) :: compute_interfaces_HUI3D, face
!!$    real(8), dimension(9) :: metric, metric_inverse
!!$    real(8), dimension(3) :: grid_vel
!!$    real(8), dimension(3,3) :: vels_transform, vels_transform_inv
!!$    real(8), dimension(21) :: geom_avg
!!$    metric = .5d0*(left(6:14)+right(6:14))
!!$    metric_inverse = MetricInverse(metric)
!!$    grid_vel = .5d0*(left(15:17)+right(15:17))
!!$    vels_transform = matmul(MetrictoMatrix(metric_inverse),row_ops_mat)
!!$    left(3:5) = matmul(left(3:5),vels_transform)
!!$    center(3:5) = matmul(center(3:5),vels_transform)
!!$    grid_vel = matmul(grid_vel,vels_transform)
!!$    geom_avg = 0d0
!!$    geom_avg(6:14) = center(6:14)
!!$    geom_avg(15:17) = grid_vel
!!$    face = riemann_solve(left,right,geom_avg,max_wave_speed_temp,0.d0)
!!$    vels_transform_inv = matmul(transpose(row_ops_mat),MetrictoMatrix(metric))
!!$    face(3:5) = matmul(vels_transform_inv,face(3:5))
!!$    compute_interfaces_HUI3D = face
!!$
!!$  end function compute_interfaces_HUI3D

  subroutine prim_update_HUI3D(main,bcextent,dt_in,CFL,nx,ny,nz)
    implicit none
    real(8), dimension(21,-1*bcextent:nx+bcextent-1,-1*bcextent:ny+bcextent-1,&
         -1*bcextent:nz+bcextent-1), intent(inout) :: main
    real(8), dimension(21,0:nx-1,0:ny-1,0:nz-1) :: main_temp
    real(8), intent(in), optional :: dt_in
    real(8), intent(in), optional :: CFL
    integer, intent(in) :: nx,ny,nz,bcextent
    integer :: i, j, k, m, n, im, jm, km, ip, jp, kp, case_no
    real(8) :: area, dv_inv, max_wave_speed_temp
    real(8), dimension(5) :: cons, prim, left_interface, right_interface
    real(8), dimension(5) :: left_flux, right_flux
    real(8), dimension(3) :: grid_vel, grid_pos
    real(8), dimension(3,3) :: row_ops_mat, vels_transform
    real(8), dimension(9) :: metric, metric_inverse
    real(8), dimension(21) :: temp, center, left, right, geom_avg
    integer, parameter :: splitting_type = 1
    real(8) :: dt, junk
    dt = dt_in
    dv_inv = 1.d0
    do n = 1, 2
       if( mod(n,2) .ne. 0 )then
          case_no = 1
          area = deta*dzeta
!!$          time = dt
          im =-1; ip = 1; jm = 0; jp = 0; km = 0; kp = 0
       else
          case_no = 2
          area = dxi*dzeta
!!$          time = dt
          jm =-1; jp = 1; im = 0; ip = 0; km = 0; kp = 0
       end if
       do k = 0, nz-1
          do j = 0, ny-1
             do i = 0, nx-1
                row_ops_mat = row_ops_mat_func(case_no)

                center = main(:,i,j,k)
                left = main(:,i+im,j+jm,k+km)
                call MUSCL_HUI(main(1:5,i+2*im,j+2*jm,k+2*km),&
                     main(1:5,i+im,j+jm,k+km),main(1:5,i,j,k),&
                     main(1:5,i+ip,j+jp,k+kp),left(1:5),center(1:5))
                metric = .5d0*(left(6:14)+center(6:14))
                metric_inverse = MetricInverse(metric)
                grid_vel = .5d0*(left(15:17)+center(15:17))
                vels_transform = matmul(&
                     MetrictoMatrix(metric_inverse),row_ops_mat)
                do m = 1, 3
                   vels_transform(n,:) = vels_transform(n,:)&
                        /sqrt(sum(vels_transform(n,:)**2))
                end do
                left(3:5) = matmul(vels_transform,left(3:5))
                center(3:5) = matmul(vels_transform,center(3:5))
                grid_vel = matmul(vels_transform,grid_vel)
                geom_avg = 0d0
                geom_avg(6:14) = center(6:14)
                geom_avg(15:17) = grid_vel
                left_interface = riemann_solve(left, center, &
                     .5d0*(left+center), max_wave_speed_temp, 0.d0)
                vels_transform = matmul(transpose(row_ops_mat),&
                     MetrictoMatrix(metric))
                do m = 1, 3
                   vels_transform(n,:) = vels_transform(n,:)&
                        /sqrt(sum(vels_transform(n,:)**2))
                end do
                left_interface(3:5) = matmul(vels_transform,left_interface(3:5))
                
                center = main(:,i,j,k)
                right = main(:,i+ip,j+jp,k+kp)
                call MUSCL_HUI(main(1:5,i+im,j+jm,k+km),&
                     main(1:5,i,j,k),main(1:5,i+ip,j+jp,k+kp),&
                     main(1:5,i+2*ip,j+2*jp,k+2*kp),center(1:5),right(1:5))
                metric = .5d0*(center(6:14)+right(6:14))
                metric_inverse = MetricInverse(metric)
                grid_vel = .5d0*(center(15:17)+right(15:17))
                vels_transform = matmul(&
                     MetrictoMatrix(metric_inverse),row_ops_mat)
                do m = 1, 3
                   vels_transform(n,:) = vels_transform(n,:)&
                        /sqrt(sum(vels_transform(n,:)**2))
                end do
                right(3:5) = matmul(vels_transform,right(3:5))
                center(3:5) = matmul(vels_transform,center(3:5))
                grid_vel = matmul(vels_transform,grid_vel)
                geom_avg = 0d0
                geom_avg(6:14) = center(6:14)
                geom_avg(15:17) = grid_vel
                right_interface = riemann_solve(center, right, &
                     .5d0*(right+center), max_wave_speed_temp, 0.d0)
                vels_transform = matmul(transpose(row_ops_mat),&
                     MetrictoMatrix(metric))
                do m = 1, 3
                   vels_transform(n,:) = vels_transform(n,:)&
                        /sqrt(sum(vels_transform(n,:)**2))
                end do
                right_interface(3:5)=matmul(vels_transform,right_interface(3:5))

                junk = sum(matmul(matmul(MetrictoMatrix(metric_inverse),&
                     row_ops_mat),matmul(transpose(row_ops_mat),&
                     MetrictoMatrix(metric)))&
                     -reshape([1d0,0d0,0d0,0d0,1d0,0d0,0d0,0d0,1d0],[3,3]))&
                     **2
                if(junk > 1d-14)then
                   write(*,*) "Inverse not working!!"
                   write(*,*) junk
                   stop
                end if
                     
                center = main(:,i,j,k)
                call primtocons(center)
                if(n==1)then
                   center(6:8) = center(6:8) + 0d0*dt*area*dv_inv*&
                        (right_interface(3:5)-left_interface(3:5))
                   left_flux = flux(left_interface,center,1)
                   right_flux = flux(right_interface,center,1)
                else if(n==2)then
                   center(9:11) = center(9:11) + 0d0*dt*area*dv_inv*&
                        (right_interface(3:5)-left_interface(3:5))
                   left_flux = flux(left_interface,center,2)
                   right_flux = flux(right_interface,center,2)
                else if(n==3)then
                   center(12:14) = center(12:14) + 0d0*dt*area*dv_inv*&
                        (right_interface(3:5)-left_interface(3:5))
                   left_flux = flux(left_interface,center,3)
                   right_flux = flux(right_interface,center,3)
                end if
                center(1:5) = center(1:5) - dt*area*dv_inv*&
                     (right_flux-left_flux)
                call constoprim(center)
                center(15:17) = center(3:5)*.0d0
                center(18:20) = center(18:20) + 0d0*dt*area*dv_inv*center(15:17)
                center(21) = Jacobian(center(6:14))

                main_temp(:,i,j,k) = center
                if(abs(main_temp(5,i,j,k)) > 1d-12)then
                   write(*,*) "z-component of velocity detected!!!"
                   read(*,*)
                end if
             end do
          end do
       end do
!!$       write(*,*) "x = ", main(18,:,ny/2-4,1)
!!$       read(*,*)
       main(:,0:nx-1,0:ny-1,0:nz-1) = main_temp
       main(15:17,0:nx-1,0:ny-1,0:nz-1) = main(3:5,0:nx-1,0:ny-1,0:nz-1)*.25d0
       main(18:20,0:nx-1,0:ny-1,0:nz-1) = main(18:20,0:nx-1,0:ny-1,0:nz-1)&
            *dt*area*dv_inv*main(15:17,0:nx-1,0:ny-1,0:nz-1)
!!$       write(*,*) "Offending pressure values are:"
!!$       write(*,*) main( 1,0,51:52,0)
!!$       write(*,*) main( 2,0,51:52,0)
!!$       write(*,*) main( 3,0,51:52,0)
!!$       write(*,*) main( 4,0,51:52,0)
!!$       write(*,*) main( 5,0,51:52,0)
!!$       write(*,*) main( 6,0,51:52,0)
!!$       write(*,*) main( 7,0,51:52,0)
!!$       write(*,*) main( 8,0,51:52,0)
!!$       write(*,*) main( 9,0,51:52,0)
!!$       write(*,*) main(10,0,51:52,0)
!!$       write(*,*) main(11,0,51:52,0)
!!$       write(*,*) main(12,0,51:52,0)
!!$       write(*,*) main(13,0,51:52,0)
!!$       write(*,*) main(14,0,51:52,0)
!!$       write(*,*) main(15,0,51:52,0)
!!$       write(*,*) main(16,0,51:52,0)
!!$       write(*,*) main(17,0,51:52,0)
!!$       write(*,*) 

    end do
  end subroutine prim_update_HUI3D

  subroutine prim_update_FV(main,bcextent,dt_in,CFL,nx,ny,nz)
! Advance the solution using the integral form of the equations
! This subroutine assumes that main is the full array of primitive variables. main 
! must also include the boundary cell values. That is, main contains a 0-index and 
! an n + 1 index containing the contents prescribed by the boundary conditions.
    implicit none
    real(8), dimension(21,-1*bcextent:nx+bcextent-1,-1*bcextent:ny+bcextent-1,&
         -1*bcextent:nz+bcextent-1), intent(inout) :: main
!f2py intent(in,out) :: main
    real(8), intent(in), optional :: dt_in
    real(8), intent(in), optional :: CFL
    integer, intent(in) :: nx,ny,nz,bcextent
    integer :: i, j, k
!    real(8), dimension(14,3,nx+1,ny+1,nz+1) :: fluxes
    real(8), dimension(14,0:nx,0:ny-1,0:nz-1) :: fluxx
    real(8), dimension(14,0:nx-1,0:ny,0:nz-1) :: fluxy
    real(8), dimension(14,0:nx-1,0:ny-1,0:nz) :: fluxz
    real(8), dimension(14,nx,ny,nz) :: temp
    real(8) :: max_wave_speed, dt, max_dt_grid
    real(8), dimension(3) :: gradXi, gradEta, gradZeta
    real(8), dimension(3) :: GradX, GradY, GradZ
    real(8), dimension(9) :: geom_avg
    real(8), dimension(3,3) :: dXidX, dXdXi
    real(8), dimension(5) :: interface_vars
    real(8), dimension(21) :: StateL, StateR
    real(8), dimension(14) :: junk
  ! Riemann_solve expects the left and right states to express velocities in
  ! grid-oriented components: normal, tangential, tangential.
    do k = 0, nz-1
       do j = 0, ny-1
          do i = 0, nx
             call compute_fluxes_FV(main(1:5,i-1,j,k), main(1:5,i,j,k),&
                  .5d0*(main(:,i-1,j,k)+main(:,i,j,k)),fluxx(:,i,j,k),&
                  1,max_wave_speed,dt=dt,dV_in=[dxi,deta,dzeta])
          end do
       end do
    end do
    do k = 0, nz-1
       do j = 0, ny
          do i = 0, nx-1
             call compute_fluxes_FV(main(1:5,i,j-1,k), main(1:5,i,j,k),&
                  .5d0*(main(:,i,j-1,k)+main(:,i,j,k)),fluxy(:,i,j,k),&
                  2,max_wave_speed,dt=dt,dV_in=[dxi,deta,dzeta],debug_flag=.true.)
          end do
       end do
    end do
    do k = 0, nz
       do j = 0, ny-1
          do i = 0, nx-1
             call compute_fluxes_FV(main(1:5,i,j,k-1), main(1:5,i,j,k),&
                  .5d0*(main(:,i,j,k-1)+main(:,i,j,k)),fluxz(:,i,j,k),&
                  3,max_wave_speed,dt=dt,dV_in=[dxi,deta,dzeta])
          end do
       end do
    end do
    max_wave_speed = max(max_wave_speed,EPS)
    if(dt_in > 0.d0)then
       dt = dt_in
    elseif(CFL>0.d0)then
       dt = min(CFL/max_wave_speed,max_dt)
       dt = min(maxval((main(6,0,0:ny-1,0:nz-1)-main(18,0,0:ny-1,0:nz-1))&
            /main(15,0,0:ny-1,0:nz-1)),dt)
    else
       write(*,*) "Error in Godunov prim_update, no time step information given"
       read(*,*)
       stop
    end if
    call primtocons(main(:,0:nx-1,0:ny-1,0:nz-1))
    main(1:14,0:nx-1,0:ny-1,0:nz-1) = main(1:14,0:nx-1,0:ny-1,0:nz-1) - (&
         (fluxx(:,1:nx,:,:)-fluxx(:,0:nx-1,:,:))*deta*dzeta + &
         (fluxy(:,:,1:ny,:)-fluxy(:,:,0:ny-1,:))*dxi*dzeta + &
         (fluxz(:,:,:,1:nz)-fluxz(:,:,:,0:nz-1))*dxi*deta &
         )*dt*dV_inv

    call constoprim(main(:,0:nx-1,0:ny-1,0:nz-1))
! Update grid velocity
!!$    call grid_velocity_update(main)
!    main(15:17,:,:,:) = main(3:5,:,:,:)*.25d0
! Update grid position
    main(18:20,0:nx-1,0:ny-1,0:nz-1) = main(18:20,0:nx-1,0:ny-1,0:nz-1) + &
         main(15:17,0:nx-1,0:ny-1,0:nz-1)*dt
! Update extra variables
  do k = 0, nz-1
     do j = 0, ny-1
        do i = 0, nx-1
           main(21,i,j,k) = Jacobian(main(6:14,i,j,k))
        end do
     end do
  end do
  end subroutine prim_update_FV

  subroutine compute_fluxes_FV(inL, inR, geom_avg, flux_vec, case_no,&
       max_wave_speed,dt,dV_in,debug_flag)
    implicit none
    real(8), dimension(:), intent(in) :: inL, inR
    real(8), dimension(5) :: StateL, StateR
    real(8), dimension(:) :: geom_avg
    real(8), dimension(3),intent(in) :: dV_in
    real(8) :: dA, dV_inv
    real(8),intent(in) :: dt
    integer, intent(in) :: case_no
    logical, intent(in), optional :: debug_flag
    real(8), dimension(:), intent(out) :: flux_vec
    real(8), intent(inout) :: max_wave_speed
    real(8), dimension(5) :: interface_vars
    real(8), dimension(3) :: GradXi, GradEta, GradZeta
    real(8), dimension(3) :: GradX, GradY, GradZ
    real(8), dimension(3,3) :: dX_dXi_u, dXi_dX_u
    real(8) :: temp_wave_speed
    integer, dimension(3,3) :: row_ops_mat
    StateL = inL
    StateR = inR
    flux_vec = 0.d0
    dV_inv = 1.d0/(product(dV_in))
    call ComputationalGrads(geom_avg(6:14),Jacobian(geom_avg(6:14)),&
         GradXi,GradEta,gradZeta)
    GradX = geom_avg(6:12:3)
    GradY = geom_avg(7:13:3)
    GradZ = geom_avg(8:14:3)
    ! Create normalized transformation matrices
    ! These matrices are given as:
    ! dXi_dX = | GradXi(1)  GradEta(1)  GradZeta(1) |
    !          | GradXi(2)  GradEta(2)  GradZeta(2) |
    !          | GradXi(3)  GradEta(3)  GradZeta(3) |
    ! However, when computing fluxes for the eta and zeta directions,
    ! these must be reordered to fit with the riemann solver, which 
    ! requires that vector components be given as | normal, tangential, tangential |.
    ! dX_dXi begins as the matrix inverse of dXi_dX, but this re-ordering,
    ! corresponding to elementary column operations, affects this inverse
    ! property. In order to mirror this effect, dX_dXi must also be 
    ! re-ordered, though with row operations instead. 
    dXi_dX_u = GradstoMatrix(GradXi/sqrt(sum(GradXi**2)),&
         GradEta/sqrt(sum(GradEta**2)),GradZeta/sqrt(sum(GradZeta**2)))
    dX_dXi_u = GradstoMatrix(GradX/sqrt(sum(GradX**2)),&
         GradY/sqrt(sum(GradY**2)),GradZ/sqrt(sum(GradZ**2)))
    dX_dXi_u = reshape([geom_avg(6),geom_avg(9),geom_avg(12),&
         geom_avg(7),geom_avg(10),geom_avg(13),&
         geom_avg(8),geom_avg(11),geom_avg(14)],[3,3])
    dXi_dX_u = MetrictoMatrix(MetricInverse(geom_avg(6:14)))
    row_ops_mat = row_ops_mat_func(case_no)
    select case(case_no)
    case(1)
       flux_vec(6:8) = -geom_avg(15:17)
       dA = dV_in(2)*dV_in(3)
    case(2)
       flux_vec(9:11) = -geom_avg(15:17)
       dA = dV_in(1)*dV_in(3)
    case(3)
       flux_vec(12:14) = -geom_avg(15:17)
       dA = dV_in(1)*dV_in(2)
    case default
       write(*,*) "Invalid case_no in compute_fluxes -- case_no = ",case_no
       stop
    end select
    dXi_dX_u = matmul(dXi_dX_u,row_ops_mat)
    dX_dXi_u = matmul(transpose(row_ops_mat),dX_dXi_u)
    if(maxval(matmul(dXi_dX_u,dX_dXi_u)-reshape([1,0,0,0,1,0,0,0,1],[3,3]))>1d-13)then
       write(*,*) "Inverses not working!"
       write(*,*) 
       write(*,*) dXi_dX_u
       write(*,*) dX_dXi_u
       write(*,*) matmul(dXi_dX_u,dX_dXi_u)-reshape([1,0,0,0,1,0,0,0,1],[3,3])
       read(*,*)
    end if
    StateL(3:5) = matmul(dXi_dX_u,StateL(3:5))
    StateR(3:5) = matmul(dXi_dX_u,StateR(3:5))
    geom_avg(15:17) = matmul(dXi_dX_u,geom_avg(15:17))
    interface_vars = riemann_solve(StateL,StateR,geom_avg,temp_wave_speed)
    interface_vars(3:5) = matmul(dX_dXi_u,interface_vars(3:5))
!!$    write(*,*) "Interface = "
!!$    write(*,*) interface_vars
    geom_avg(15:17) = matmul(dX_dXi_u,geom_avg(15:17))
!!$    geom_avg(6:14) = geom_avg(6:14)-flux_vec(6:14)*dt*dV_inv
!!$    flux_vec(6:14) = 0.d0
    flux_vec(1:5) = flux(interface_vars,geom_avg,case_no)
    max_wave_speed = max(max_wave_speed,temp_wave_speed)
  end subroutine compute_fluxes_FV

  function row_ops_mat_func(case_no)
    implicit none
    integer, dimension(3,3) :: row_ops_mat_func, row_ops_mat
    integer, intent(in) :: case_no
        select case(case_no)
    case(1)
       row_ops_mat = reshape([1,0,0,0,1,0,0,0,1],[3,3])
    case(2)
       row_ops_mat = reshape([0,1,0,1,0,0,0,0,1],[3,3])
    case(3)
       row_ops_mat = reshape([0,0,1,1,0,0,0,1,0],[3,3])
    case default
       write(*,*) "Invalid case_no in compute_fluxes -- case_no = ",case_no
       stop
    end select
    row_ops_mat_func = row_ops_mat
  end function row_ops_mat_func

  function flux(in,geom_avg,case_no)
    implicit none
    real(8), dimension(:), intent(in) :: in, geom_avg
    integer, intent(in) :: case_no
    real(8), dimension(5) :: flux
    real(8) :: D, grads(3,3), grad(3), J, Jinv
!!$    write(*,*) "Got this far"
    J = geom_avg(21)
    J = Jacobian(geom_avg(6:14))
    Jinv = 1.d0/geom_avg(21)
    call ComputationalGrads(geom_avg(6:14),J,grads(:,1),grads(:,2),grads(:,3))
    grad = grads(:,case_no)
    D = sum(([ in(3), in(4), in(5) ] - &
         [ geom_avg(15), geom_avg(16), geom_avg(17) ])*grad)
    flux = [&
         in(2)*J*D, &
         in(2)*J*D*in(3) + J*grad(1)*in(1), &
         in(2)*J*D*in(4) + J*grad(2)*in(1), &
         in(2)*J*D*in(5) + J*grad(3)*in(1), &
         in(2)*J*D*energy_func(in(1:5)) + J*sum(grad*in(3:5))*in(1) ]
!!$    write(*,*) "J = ", J
!!$    write(*,*) "D = ", D
!!$    write(*,*) "e = ", energy_func(in(1:5))
!!$    write(*,*) "v = ", in(3:5)
!!$    write(*,*) "V = ", geom_avg(15:17)
!!$    write(*,*) "grad = ", grad
!!$    write(*,*) "Energy term = ", J*in(2)*D*energy_func(in(1:5))
!!$    write(*,*) "Case No. = ", case_no
  end function flux

  subroutine MUSCL_HUI(leftleft, left, right, rightright, outleft, outright)
    implicit none
    real(8), dimension(5), intent(in) :: leftleft, left, right, rightright
    real(8), dimension(5), intent(out) :: outleft, outright
    integer :: n
    
    do n = 1, 5
       outleft(n)  =  left(n) + 5d-1*( left(n) - leftleft(n))*minmod(&
            (right(n)-left(n))/( left(n) - leftleft(n)))
       outright(n) = right(n) - 5d-1*(rightright(n)-right(n))*minmod(&
            (right(n)-left(n))/(rightright(n)-right(n)))
    end do
    outleft  =  left + 5d-1*( left - leftleft)*&
         minmod((right-left)/( left - leftleft))
    outright = right - 5d-1*(rightright-right)*&
         minmod((right-left)/(rightright-right))
    
  contains
    elemental function minmod(in)
      implicit none
      real(8), intent(in) :: in
      real(8) :: minmod
      minmod = max(0d0,min(1d0,in))
    end function minmod
  end subroutine MUSCL_HUI

end module Godunov

module Godunov_tester
  ! Test the following routines:
  ! function riemann_solve(left, right, geom_avg, max_wave_speed, verbose_flag, t_out)
  ! function energy_func(in)
  ! subroutine primtocons(main,nx,ny,nz)
  ! subroutine constoprim(main,nx,ny,nz)
  ! function invnorm3(in)
  ! subroutine grid_coords(grad, normal, tangential1, tangential2)
  ! subroutine prim_update(main,bcextent,dt_in,CFL,nx,ny,nz)
  ! subroutine compute_fluxes(inL, inR, geom_avg, flux_vec, case_no,&
  !      max_wave_speed,dt,dV_in,debug_flag)
  ! function flux(in,geom_avg,case_no)
  use Godunov
contains
  integer function GodErrorReader(in)
    integer, intent(in) :: in
    select case(in)
    case(0) 
       write(*,*) "   All tests passed"
    case(1)
       write(*,*) "   Primitive-Conservative mutual inverse test failed"
    case(2)
       write(*,*) "   Grid_coords failed to return an orthonormal system"
    case(3)
       write(*,*) "   Flux fails provided test problem"
    case default
       write(*,*) "   Unexpected error code"
    end select
    GodErrorReader = 0
  end function GodErrorReader

  integer function GodTester()
    use TimeAdvancementStuff
    implicit none
    real(8), dimension(21,3,4,3) :: main
    integer :: i, j, nx, ny
    real(8), dimension(5) :: riemann_test
    real(8), dimension(21) :: geom_test
    real(8), dimension(21,3,3,3) :: constoprimtest1, constoprimtest2
    real(8), dimension(5) :: left_test, right_test
    real(8) :: max_wave_speed
    real(8), dimension(3) :: grad, norm, tan1, tan2
    real(8) :: test1, test2, test3
    real(8), dimension(21), parameter :: flux_seed = [0.270991,0.0613936,&
         0.748627,0.24336,0.374409,-0.423353,0.323678,-0.333788,-0.53982,&
         -0.991525,0.75888,-0.921888,-0.631486,0.801117,0.634729,-0.750043,&
         0.412858,-0.0734701,-0.0563167,0.97121,1.]
    real(8), dimension(5), parameter :: flux_test_x = [-0.0171431,-0.0982248,&
         -0.0765652,-0.161747,-0.335386]
    real(8), dimension(5), parameter :: flux_test_y = [-0.0384556,-0.0419378,&
         -0.184655,-0.167707,-0.548871]
    real(8), dimension(5), parameter :: flux_test_z = [0.0285833,-0.00172451,&
         0.142847,0.171804,0.402354]
    real(8), dimension(21,62,102,3) :: riemann_test_array
    real(8), dimension(21,102,3,3) :: riemann_test_array_1d
    integer :: n
    
    GodTester = 0

    ! Check that primtocons and constoprim are mutual inverses
    ! Are there invertibility problems from non-physical variables,
    ! such as negative pressures, etc? Random_number only returns
    ! positive numbers, I suppose.
    call random_number(constoprimtest1)
    constoprimtest2 = constoprimtest1
    call constoprim(constoprimtest1)
    call primtocons(constoprimtest1)
    if(sqrt(sum((constoprimtest1-constoprimtest2)**2)&
         /size(constoprimtest1))>EPS) GodTester = 1

    ! Ensure that the coordinate system returned from grid_coords
    ! is orthonormal, and that norm is parallel to grad.
    
    call random_number(grad)
    grad = grad - .5d0
    call grid_coords(grad, norm, tan1, tan2)
    if(maxval(abs([norm2(norm), norm2(tan1), norm2(tan2)]-1.d0))>EPS)then
       GodTester = 2
    end if
    if(dot_product(grad/norm2(grad),norm)-1.d0>EPS) GodTester = 2
    if(abs(dot_product(norm,tan1))>EPS) GodTester = 2
    if(abs(dot_product(norm,tan2))>EPS) GodTester = 2
    if(abs(dot_product(tan1,tan2))>EPS) GodTester = 2
       
    ! Test flux routine against Mathematica-generated test problem & solution
    ! Mathematica only returns to a set precision.
    if(sqrt(sum((flux(flux_seed(1:5),flux_seed,1) - flux_test_x)**2)/5.)>EPSs)then
       GodTester = 3
    end if
    if(sqrt(sum((flux(flux_seed(1:5),flux_seed,2) - flux_test_y)**2)/5.)>EPSs)then
       GodTester = 3
    end if
    if(sqrt(sum((flux(flux_seed(1:5),flux_seed,3) - flux_test_z)**2)/5.)>EPSs)then
       GodTester = 3
    end if

    ! It is important to also test prim_update, though the only known way 
    ! to do this is via specific convergence testing. For now, that testing
    ! must be approved manually.
    ! subroutine prim_update(main,bcextent,dt_in,CFL,nx,ny,nz)

    call RieInit1D(riemann_test_array_1d)
    nx = size(riemann_test_array_1d,2)
    ny = size(riemann_test_array_1d,3)
    call write_files_matlab(riemann_test_array_1d(:,:,:,2),1d-4*n,&
         nx,ny,.true.)!(x,y,E,h,t,dt)
    do n = 1, 5000
       if(n*1d-3>25d-2) exit
       write(*,*) "time step = ", n
       call prim_update(riemann_test_array_1d,1,1d-3,.7d0,100,1,1)
       riemann_test_array_1d(:,:,1,:) = riemann_test_array_1d(:,:,2,:)
       riemann_test_array_1d(:,:,3,:) = riemann_test_array_1d(:,:,1,:)
       riemann_test_array_1d(:,:,:,1) = riemann_test_array_1d(:,:,:,2)
       riemann_test_array_1d(:,:,:,3) = riemann_test_array_1d(:,:,:,2)
       call write_files_matlab(riemann_test_array_1d(:,:,:,2),1d-3*n,&
            nx,ny,.false.)!(x,y,E,h,t,dt)

       !write(*,*) riemann_test_array_1d(1,20:60,1,1) 
    end do
       
         ! subroutine prim_update(main,bcextent,dt_in,CFL,nx,ny,nz)

    write(*,*) "Got this far!!"
    write(*,*) riemann_test_array_1d(1,:,2,2)
    
  end function GodTester

  subroutine RieInit1D(main)
    implicit none
    real(8), dimension(21,-1:100,-1:1,-1:1) :: main
    integer :: i
    main = 0d0
    main(1,-1:49,:,:) = 1d0 ; main(1,50:100,:,:) = 1d-1
    main(2,-1:49,:,:) = 1d0 ; main(2,50:100,:,:) = 125d-3
    main(3,-1:49,:,:) = 0d0 ; main(3,50:100,:,:) = 0d0
    main(4,:,:,:) = 0d0 ; main(5,:,:,:) = 0d0
    main(6,:,:,:) = 1d-2 ; main(10,:,:,:) = 1d-2 ; main(14,:,:,:) = 1d-2
    do i = -1, 100
       main(18,i,:,:) = (real(i,8)+.5d0)*1d-2
    end do
    main(21,:,:,:) = 1d-6
  end subroutine RieInit1D

  subroutine GodRieInit(main)
    implicit none
    real(8), dimension(21,62,102,3), intent(inout) :: main
    integer :: i, j

    main( 1,:,:,:) = 1.d0
    main( 2,:,:,:) = 1.d0
    main( 3,:,:,:) = 2.4d0*sqrt(1.4d0*main(1,:,:,:)/main(2,:,:,:))
    main( 4,:,:,:) = 0.d0
    main( 5,:,:,:) = 0.d0
    main( 6,:,:,:) = 1.d0/99.d0
    main( 7,:,:,:) = 0.d0
    main( 8,:,:,:) = 0.d0
    main( 9,:,:,:) = 0.d0
    main(10,:,:,:) = 1.d0/99.d0
    main(11,:,:,:) = 0.d0
    main(12,:,:,:) = 0.d0
    main(13,:,:,:) = 0.d0
    main(14,:,:,:) = 1.d0
    main(15,:,:,:) = .25d0*main(3,:,:,:)
    main(16,:,:,:) = 0.d0
    main(17,:,:,:) = 0.d0
    main(18,:,:,:) = 0.d0
    do j = 2, size(main,3)-1
       do i = 2, size(main,2)-1
          main(19,i,j,2) = 1.d0/100.d0*(i-1.5d0)
          main(20,i,j,2) = 0.d0
          main(21,i,j,2) = Jacobian(main(6:14,i,j,2))
       end do
    end do
    main(1,:,size(main,3)/2+1:size(main,3),:) = .25d0
    main(2,:,size(main,3)/2+1:size(main,3),:) = .5d0
    main(3,:,size(main,3)/2+1:size(main,3),:) = 7.d0*&
         sqrt(1.4d0*.25d0/.5d0)
    main(15,:,:,:) = .25d0*main(3,:,:,:)
  end subroutine GodRieInit
end module Godunov_tester

program Godunov_tester_program
  use Godunov_tester
  use Riemann_tester
  integer :: result, junk
  result = GodTester()
  write(*,*) "Godunov_tester_program: "
  junk = GodErrorReader(result)
  result = RieTester()
  write(*,*) "Riemann_tester_program: "
  junk = RieErrorReader(result)
end program Godunov_tester_program

!!$module grid_velocity
!!$contains
!!$  subroutine grid_velocity_update(main)
!!$    implicit none
!!$    
!!$
!!$  end subroutine grid_velocity_update
!!$end module grid_velocity
