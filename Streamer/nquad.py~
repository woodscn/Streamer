from scipy.integrate import quad
import numpy
class NQuadError(Exception):
    pass
def nquad(func,ranges,args=(),opts=()):
    """
Integration over multiple variables.

Wraps scipy.integrate.quad to enable integration over multiple variables.
Various options allow improved integration of discontinuous functions, as 
well as the use of weighted integration, and generally finer control of the
integration process.

Parameters
----------
func : callable object
    The function to be integrated. Has arguments of x0, ... xn, t0, ... tn,
    where integration is carried out over x0, ... xn, which must be floats.
    Function signature should be func(x0,x1,...xn,t0,t1,...tn). Integration
    is performed in order: x0, x1, ... xn.
ranges : iterable object
    Each element of ranges may be either a sequence 2 numbers, or else a 
    callable that returns such a sequence. ranges[0] corresponds to 
    integration over x0, and so on. If an element of ranges is a callable,
    then it will be called with all of the integration arguments available.
    e.g. if func = f(x0,x1,x2), then ranges[0] may be defined as either
    (a,b) or else as (a,b) = range0(x1,x2). 
args : iterable object, optional
    Additional arguments t0, ... tn, required by func.
opts : iterable object or dict, optional
    Options to be passed to scipy.integrate.quad. May be empty, a dict, or
    a sequence of dicts or functions that return a dict. If empty, the 
    default options from scipy.integrate.quadare used. If a dict, the same 
    options are used for all levels of integraion. If a sequence, then each
    element of the sequence corresponds to a particular integration. e.g. 
    opts[0] corresponds to integration over x0, and so on. The available 
    options together with their default values (as of Apr 2013) are:
    - epsabs = 1.49e-08
    - epsrel = 1.49e-08
    - limit  = 50
    - points = None
    - weight = None
    - wvar   = None
    - wopts  = None
    The full_output option from quad is unavailable, due to the complexity
    of handling the large amount of data such an option would return for 
    this kind of nested integration. For more information on these options,
    consult the documentation for scipy.integrate.quad

Returns
-------
result : float
    The result of the integration
abserr : float
    The maximum of the estimates of the absolute error in the various 
    integration results

See Also
--------
scipy.integrate.quad : 1-dimensional Gaussian integration.

Examples
--------
>>> func = lambda x0,x1,x2,x3 : x0**2+x1*x2-x3**3+numpy.sin(x0)+(
        1 if (x0-.2*x3-.5-.25*x1>0) else 0)
>>> points=[[lambda (x1,x2,x3) : .2*x3+.5+.25*x1],[],[],[]]
>>> def opts0(*args,**kwargs):
        return {'points':[.2*args[2]+.5+.25*args[0]]}
>>> nquad(func,[[0,1],[-1,1],[.13,.8],[-.15,1]],opts=[opts0,{},{},{}])
(1.5267454070738635, 2.943736000140233e-14)
"""
    return _NQuad()._nquad(func,ranges,args,opts)
class _NQuad(object):
    def __init__(self):
        self.abserr = 0
    def _nquad(self,func,ranges,args=(),opts=(),_depth=0,_int_vars=()):
        total_args = _int_vars+args
        # Select the range and opts for the given depth of integration.
        ind = -_depth-1
        import pdb;pdb.set_trace()
        if callable(ranges[ind]):
            current_range = ranges[ind](*total_args)
        else:
            current_range = ranges[ind]
        if callable(opts):
            current_opts = opts(*total_args)
        else: 
            current_opts = opts
        if isinstance(opts,dict):
            current_opts = opts
        else:
            if not (len(opts) in [0,len(ranges)]):
                raise NQuadError('Invalid opts specification')
            current_opts = opts[ind]
        if len(opts) != 0:
            if callable(current_opts):
                current_opts = current_opts(*total_args)
            else:
                current_opts = current_opts
        else:
            current_opts = {}
        try:
            if current_opts["full_output"] != 0:
                raise NQuadError('full_output option is disabled!')
        except(KeyError):
            pass
        # Check to make sure that all points lie within the specified range.
        try:
            for point in current_opts["points"]:
                if point < current_range[0] or point > current_range[1]:
                    current_opts["points"].remove(point)
        except(KeyError):
            pass
        # Check to see if down to 1-D integral.
        if current_range is ranges[0]:
            func_new = func
        else:
            # Define a new integrand.
            import pdb;pdb.set_trace()
            def func_new(*total_args):
                return self._nquad(func,ranges,args=total_args[1:],opts=opts,
                                   _depth=_depth+1,_int_vars=_int_vars)
        out = quad(func_new,*current_range,args=_int_vars+args,**current_opts)
        self.abserr = max(out[1],self.abserr)
        result = out[0]
        if _depth == 0:
            return result,self.abserr
        else:
            return result

if __name__=='__main__':
    func = lambda x0,x1,x2,x3 : x0**2+x1*x2-x3**3+numpy.sin(x0)+(
        1 if (x0-.2*x3-.5-.25*x1>0) else 0)
    points=[[lambda (x1,x2,x3) : .2*x3+.5+.25*x1],[],[],[]]
    def opts0(*args,**kwargs):
        return {'points':[.2*args[2]+.5+.25*args[0]]}
#    print nquad(func,[[0,1],[-1,1],[.13,.8],[-.15,1]],
#                opts=[opts0,{},{},{}])
    def func(x0,x1,x2,x3,t0,t1):
        return x0*x1*x3**2+numpy.sin(x2)+1+(1 if x0+t1*x1-t0>0 else 0)
    def lim0(x1,x2,x3,t0,t1):
        return x1**2+x2+numpy.cos(x3)*t0*t1, x1**2+x2+numpy.cos(x3)*t0*t1+2
    def lim1(x2,x3,t0,t1):
        return t0*x2+t1*x3-1,t0*x2+t1*x3+1
    def lim2(x3,t0,t1):
        return x3+t0**2*t1**3-1, x3+t0**2*t1**3+1
    def lim3(t0,t1):
        return t0+t1-1,t0+t1+1
    def opts(x1,x2,x3,t0,t1):
        return {'points':t0-t1*x1}
    print nquad(func,[lim0,lim1,lim2,lim3],args=(0,0),opts=[opts,{},{},{}])

