from copy import deepcopy

import numpy
import sympy
import scipy.integrate
import Euler_UCS_manufactured
import multiprocessing
from sympy.core.cache import clear_cache
from sympy.utilities.lambdify import lambdify

import myquad
import shocked_solutions
from smooth_solutions import smooth_sols_1
from symbolic_solution import sym_sol
class Error(Exception):
    pass
class IntegrableFunction:

    """
    Inputs:
      SymPy expression for a possibly vector-valued function
      SymPy expressions for various discontinuities
      List of SymPy variables of integration in order e.g. (xi,eta,t)
        ((xi,0,1),(eta,1.3,1.5),(t,-1,1))

    Outputs:
      Function that accepts coordinate values and evaluates the input
      Ranges list for mul_quad
      Args list for mul_quad
      Opts list for mul_quad
    """

    def __init__(self,sympy_function,sympy_ranges,sympy_discontinuities=(),args={}):
        self.int_variables,self.min_ranges,self.max_ranges=zip(*sympy_ranges)
        self.int_variables = list(self.int_variables)
        self.ranges = zip(self.min_ranges,self.max_ranges)
        self.args=args
        self.sympy_variables = self.int_variables
        self.function = Integrand(
            sympy_function,self.sympy_variables,args=self.args)
        
        int_variables_init = list(self.int_variables)
        discs = list(sympy_discontinuities)
        self.opts = []
        for var in self.int_variables:
            points = []
            int_variables_init.remove(var)
            for disc in discs:
                solved = sympy.solve(disc,var)
                if len(solved) > 0:
                    for solve in solved:
                        points.append(DiscFunction(solve,int_variables_init,
                                                   args=self.args))
                    discs.remove(disc)
            if len(points) > 0:
                self.opts.append(OptionsDict(points))
            else:
                self.opts.append({})
    
    def quad_integrate(self):
        return myquad.mul_quad(self.function,self.ranges,opts=self.opts)

    def mc_integrate(self):
        """
        Evaluate the integral of a function using the Monte Carlo technique.

        mc_integrate(f,ranges,calls,args=())

        Monte Carlo integration is a robust, though inaccurate, method of
        integration. mc_integrate evaluates function f ncalls number of 
        times at random points, and uses the sum of these evaluations to 
        compute the integral of function f over the rectangular volume 
        specified by ranges. The error of the integral scales as 
        1/sqrt(ncalls)

        Inputs:
          f - Callable that returns a number. Must have at least as many 
            number arguments as the number of ranges provided.
          ranges - Sequence of ranges over which to evaluate the integral.
          ncalls - Number of function samples to take. 
          args - Any additional arguments required by f

        Example:
          mc_integrate(f(x,y,z),((0,1),(-.5,.5)),10000,args=3) evaluates
          the integral of f(x,y,z) over the range x=(0,1), y=(-.5,.5), 
          at z=3. The function is sampled 10e4 times, and so the error
          can be expected to be around 0.01.
        """
        f_sum = 0
        for n in xrange(ncalls):
            coords_lst = []
            for rng in ranges:
                coords_lst.append(rng[0] + rng[1]*numpy.random.random())
            f_sum += self.function(coords_lst)
        vol = numpy.prod([float(rng[1])-float(rng[0]) for rng in ranges])
        return vol/calls*f_sum

class OptionsDict(object):
    def __init__(self,points):
        self.points = points
    def __call__(self,*args):
        return {"points":[point(*args) for point in self.points]}

class DiscFunction(object):
    def __init__(self,solved,sympy_variables,args={}):
        self.disc_symbolic = solved.subs(args)
        self.other_sympy_vars = list(sympy_variables)
        self.lambdified = lambdify(self.other_sympy_vars,self.disc_symbolic)
        return None
    def __call__(self,*args):
        if len(args) != len(self.other_sympy_vars):
            print 'args = ',args
            print 'expected args = ',self.other_sympy_vars
            import pdb;pdb.set_trace()
            raise Error('Error in DiscFunction call! Invalid args list!')
        return self.lambdified(*args)

class Integrand(object):
    def __init__(self,sympy_function,sympy_variables,args={}):
        self.sympy_function = sympy_function.subs(args)
        self.sympy_variables = sympy_variables
        self.lambdified = lambdify(self.sympy_variables,self.sympy_function)
        return None
    def __call__(self,*args):
        if len(args) != len(self.sympy_variables):
            print 'args = ',args
            print 'sympy_vars = ',self.sympy_variables
            raise Error('invalid argument list given in call to Integrand!')
        return self.lambdified(*args)

#class BalanceLaw(object):
#    def __init__(self,inputs,discs):
#        self.source = inputs.pop()
#        self.fluxes = list(inputs)
#        self.discs = discs

def int_eqn_sum(eqn_obj,sol,t_range,xi_range,eta_range,zeta_range):
    cons,flux1,flux2,flux3,source = eqn_obj(sol)
#    calls = 10000
    cons_int_lst = [];flux1_int_lst = [];flux2_int_lst = [];flux3_int_lst = []
    for elem in cons:
        left = IntegrableFunction(elem,(xi_range,eta_range,zeta_range),
                                  sol['discontinuities'],
                                  args={t_range[0]:t_range[1]}
                                  ).quad_integrate()
        right = IntegrableFunction(elem,(xi_range,eta_range,zeta_range),
                                  sol['discontinuities'],
                                   args={t_range[0]:t_range[2]}
                                  ).quad_integrate()
#        left = mc_integrate(cons_sample,(xi_range,eta_range,zeta_range),
#                            calls,args=(t_range[0],elem))
#        right = mc_integrate(cons_sample,(xi_range,eta_range,zeta_range),
#                             calls,args=(t_range[1],elem))
#        left = scipy.integrate.tplquad(
#            quad_sample,xi_range[0],xi_range[1],lambda x:eta_range[0],
#            lambda x:eta_range[1],lambda x,y:zeta_range[0],
#            lambda x,y:zeta_range[1],args=(t_range[0],elem,cons_sample))
#        right = scipy.integrate.tplquad(
#            quad_sample,xi_range[0],xi_range[1],lambda x:eta_range[0],
#            lambda x:eta_range[1],lambda x,y:zeta_range[0],
#            lambda x,y:zeta_range[1],args=(t_range[1],elem,cons_sample))
        cons_int_lst.append(right[0]-left[0])
#        print left,right
    print "Done with cons"
    for elem in flux1:
        left = IntegrableFunction(elem,(t_range,eta_range,zeta_range),
                                  sol['discontinuities'],
                                  args={xi_range[0]:xi_range[1]}
                                  ).quad_integrate()
        right = IntegrableFunction(elem,(t_range,eta_range,zeta_range),
                                  sol['discontinuities'],
                                   args={xi_range[0]:xi_range[2]}
                                  ).quad_integrate()

#        left = mc_integrate(flx1_sample,(t_range,eta_range,zeta_range),
#                            calls,args=(xi_range[0],elem))
#        right = mc_integrate(flx1_sample,(t_range,eta_range,zeta_range),
#                             calls,args=(xi_range[1],elem))
#        left = scipy.integrate.tplquad(
#            quad_sample,t_range[0],t_range[1],lambda x:eta_range[0],
#            lambda x:eta_range[1],lambda x,y:zeta_range[0],
#            lambda x,y:zeta_range[1],args=(xi_range[0],elem,flx1_sample))
#        right = scipy.integrate.tplquad(
#            quad_sample,t_range[0],t_range[1],lambda x:eta_range[0],
#            lambda x:eta_range[1],lambda x,y:zeta_range[0],
#            lambda x,y:zeta_range[1],args=(xi_range[1],elem,flx1_sample))
        flux1_int_lst.append(right[0]-left[0])
#        print left,right
    print "Done with flx1"
    for elem in flux2:
        left = IntegrableFunction(elem,(t_range,xi_range,zeta_range),
                                  sol['discontinuities'],
                                  args={eta_range[0]:eta_range[1]}
                                  ).quad_integrate()
        right = IntegrableFunction(elem,(t_range,xi_range,zeta_range),
                                  sol['discontinuities'],
                                   args={eta_range[0]:eta_range[2]}
                                  ).quad_integrate()
#        left = mc_integrate(flx2_sample,(t_range,xi_range,zeta_range),
#                            calls,(eta_range[0],elem))
#        right = mc_integrate(flx2_sample,(t_range,xi_range,zeta_range),
#                             calls,(eta_range[1],elem))
#        left = scipy.integrate.tplquad(
#            quad_sample,t_range[0],t_range[1],lambda x:xi_range[0],
#            lambda x:xi_range[1],lambda x,y:zeta_range[0],
#            lambda x,y:zeta_range[1],args=(eta_range[0],elem,flx2_sample))
#        right = scipy.integrate.tplquad(
#            quad_sample,t_range[0],t_range[1],lambda x:xi_range[0],
#            lambda x:xi_range[1],lambda x,y:zeta_range[0],
#            lambda x,y:zeta_range[1],args=(eta_range[1],elem,flx2_sample))
        flux2_int_lst.append(right[0]-left[0])
#        print left,right
    print "Done with flx2"
    for elem in flux3:
        left = IntegrableFunction(elem,(t_range,xi_range,eta_range),
                                  sol['discontinuities'],
                                  args={zeta_range[0]:zeta_range[1]}
                                  ).quad_integrate()
        right = IntegrableFunction(elem,(t_range,xi_range,eta_range),
                                  sol['discontinuities'],
                                   args={zeta_range[0]:zeta_range[2]}
                                  ).quad_integrate()
#        left = mc_integrate(flx3_sample,(t_range,xi_range,eta_range),
#                            calls,(zeta_range[0],elem))
#        right = mc_integrate(flx3_sample,(t_range,xi_range,eta_range),
#                             calls,(zeta_range[1],elem))
#        left = scipy.integrate.tplquad(
#            quad_sample,t_range[0],t_range[1],lambda x:xi_range[0],
#            lambda x:xi_range[1],lambda x,y:eta_range[0],
#            lambda x,y:eta_range[1],args=(zeta_range[0],elem,flx3_sample))
#        right = scipy.integrate.tplquad(
#            quad_sample,t_range[0],t_range[1],lambda x:xi_range[0],
#            lambda x:xi_range[1],lambda x,y:eta_range[0],
#            lambda x,y:eta_range[1],args=(zeta_range[1],elem,flx3_sample))
        flux3_int_lst.append(right[0]-left[0])
#        print left,right
    print "Done with flx3"
    source = [0 for elem in cons]
#    import pdb;pdb.set_trace()
    return (numpy.array(cons_int_lst)+numpy.array(flux1_int_lst)+
            numpy.array(flux2_int_lst)+numpy.array(flux3_int_lst)+
            numpy.array(source))

if __name__=="__main__":
    t=sympy.Symbol('t')
    xi=sympy.Symbol('xi')
    eta=sympy.Symbol('eta')
    zeta=sympy.Symbol('zeta')
#    sympy_function = t+xi**2+eta**3-zeta+sympy.functions.Heaviside(xi+3*t)
#    sympy_ranges = ((t,0,1),(xi,2,3),(eta,4,5))
#    sympy_discontinuities = (xi+3*t,)
#    junk = IntegrableFunction(sympy_function,sympy_ranges,sympy_discontinuities,args={zeta:0})
#    junk2 = junk.quad_integrate()
#    print junk2
#    junk = Euler_UCS_manufactured.Euler_UCS()
#    sol=shocked_sol_1()
#    junk2 = junk(sol)
#    func = IntegrableFunction(junk2[2][2],((t,0,1),(xi,0,1),(zeta,0,1)),
#                              sol['discontinuities'],args={eta:0})
#    print func.quad_integrate()
#    import pdb;pdb.set_trace()
    print int_eqn_sum(Euler_UCS_manufactured.Euler_UCS(),
                      shocked_solutions.oblique_shock(),
                      (t,0,1),(xi,0,1),(eta,0,1),(zeta,0,1))

